<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<p>
		Ввиду отсутствия в вашей компании сильного JavaScript разработчика, я могу предложить вам несколько вопросов, которые позволят вам определить уровень знаний собеседуемого в нативном JvaScript.
	</p>
	<h2>Легкие вопросы:</h2>
	<ol>
		<li>
			<h3>Что выведется, если ввести в консоль следующее выражение: <strong>0,5+0,5</strong></h3>
			<p>Ответ будет 5</p>
			<p>В данном случае разработчик дожен заметить, что 0,5 - это не 0.5, а 0 затем оператор запятая, затем пять. В итоге эта надпись интерпритируется как 0,5,5. При записи нескольких примитивов, идущих через оператор запятую, в консоли выводится последий из них, то есть 5.</p>
		</li>
		<li>
			<h3>Что выведется, если ввести в консоль следующее выражение: <strong>let a = {key: 'value'}; a.toString()</strong></h3>
			<p>Ответ будет <pre>'[object Object]'<pre></p>
			<p>В данном случае программист должен знать, что метод toString объекта возвращает не его содержимое, а вышеуказанную строку. Чтобы получить строкой ключи и значения массива, необходимо использовать JSON.parse()</p>
		</li>
		<li>
			<h3>Что выведется, если ввести в консоль следующее выражение: <strong>let a = 5; let a = a + 5; a</strong></h3>
			<p>Ответом будет ошибка</p>
			<p>Здесь нужно помнить, что через let можно определить переменную только один раз, в отличае от определения через var.</p>
		</li>
		<li>
			<h3>Что выведется, если ввести в консоль следующее выражение: <strong>[1, 2, 3] + [4, 5, 6]</strong></h3>
			<p>Ответом будет '1,2,34,5,6'</p>
			<p>При сложении массива с другим массивом, либо со строкой, складывается не сам массив, а результат действия его метода toString. Этот метод возвращает строкой все его аргументы, отделяя их запятой. В случае, когда массив пустой, этот метод возвращает пустую строку. В итоге наша первоначальная задача эквивалентна сложению двух строк: '1,2,3' + '4,5,6'</p>
		</li>
		<li>
			<h3>Что выведется, если ввести в консоль следующее выражение: <strong>'B' + 'a' +   + 'a' + 'a'</strong></h3>
			<p>Ответом будет 'BaNaNa'</p>
			<p>Оператор +, стоящий перед строкой преобразует ее в NaN. Поэтому условие эквивалентно снедующему выражению: 'B' + 'a' + NaN + 'a'</p>
		</li>
		<li>
			<h3>Что выведется, если ввести в консоль следующее выражение: <strong>!!false === !!'false'</strong></h3>
			<p>Ответом будет false</p>
			<p>Здесь нужно помнить, что любая строка, кроме строки нулевой длинны возвращает true. В итоге получаем false === true, что выведет false</p>
		</li>
	</ol>
	<h2>Средние вопросы:</h2>
	<ol>
		<li>
			<h3>что выведет в консоль: <strong>typeof /moz/gi;</strong>, и что за выражение находится после typeof?</h3>
			<p>правильный ответ: "object"</p>
			<p>
				То что это регулярное выражение кандидат должен определить легко, так же он должел рассказать что это регулярка для поиска повторений "moz" в строке.
				Причем должен знать значения флагов

				g: поиск глобально, тоесть ответом будет массив включающий в себя все повторы
				i: игнорирование регистра при сопоставлении (заглавные буквы и маленькие ищет одинаково)

				например:

				"11111moz111moz1111moz".match(/moz/gi)  // -> вернет ["moz", "moz", "moz"]
				"11111moz111moz1111moz".match(/moz/g)  // -> вернет 1 повтор но с мета данными ["moz", index: 5, input: "11111moz111moz1111moz", groups: undefined]

				вообще если кандидат сможет перечислить все пять флагов то это очень хороший специалист:

				m ->
				  сопоставление по нескольким строкам; символы начала и конца (^ и $) начинают работать по нескольким строкам (то есть, происходит сопоставление с началом или концом каждой строки (строки разделяются символами \n или \r), а не только с началом или концом всей вводимой строки)
				u ->
				   обрабатывать шаблон как Unicode 
				y
				   липкий; совпадает только с индексом, указанным свойством lastIndex этого регулярного выражения в целевой строке (и не пытается совпадать с любыми более поздними индексами).
			</p>
		</li>
		<li>
			<h3>какое будет состояние state когда мы попробуем его изменить таким образом 
				<pre>
					state = {
					    count:0
					}

					this.setState({count: this.state.count + 1});
					this.setState({count: this.state.count + 1});
					this.setState({count: this.state.count + 1});
				</pre>
			</h3>
			<p>Правильный ответ: </p>
			<pre>
			{
				count:1
			}
			</pre>
					
			<p>
				Поскольку функция setState в реакте асинхронна, state не изменяется мгновенно, поэтому следующий вызов setState получает старое состояние, равное 0. В итоге каждый раз состоянию count будет присваиваться 0 + 1, т.е. единица.
				для того что бы правильно отработать эту операцию и получить 3, ее нужно обрабатывать через callback функции
				<pre>
					this.setState({ count: this.state.count + 1 }, () => {
					   this.setState({ count: this.state.count + 1 }, () => {
					       this.setState({ count: this.state.count + 1 });
					   });
					});
				</pre>
				Тогда следующий вызов функции setState гарантированно произойдет после того, как state изменится.
			</p>
		</li>
		<li>
			<h3>что это за конструкция и для чего она нужна:
				<pre>
					<>
						{
						   //...code
						}
					</>
				</pre>
			</h3>
			<p>
				Это конструкция позволяет избегать создания в качестве рутового компонента какой то DOM элемент.
			</p>
		</li>
	</ol>
	<h2>Сложные вопросы:</h2>
	<ol>
		<li>
			<h3>Что выведется в консоли, и через какое время: 
				<pre>
					const promise = new Promise(function(resolve, reject) {

					  setTimeout(function() {
					  	console.log('Resolve Time');
					    resolve("OK");
					  }, 2000);

					  setTimeout(function() {
					  	console.log('Reject Time');
					    reject("FAIL!");
					  }, 1000);

					});

					promise.then(function(result) {
					  console.log("Result", result);
					}, function(err) {
					  console.log("Caught", err);
					});
				</pre>
			</h3>
			<p>Ответ: через секунду выведется 'Reject Time' и сразу же после этого 'Caught FAIL!'. Затем еще спустя одну секунду 'Resolve Time'</p>
			<p>
				Здесь нужно понимать, как работают промисы. У промиса есть два состояния: resolve и reject. Первый используется при успешной работе, второй обычно выводит ошибку, если что-то пошло не так. Код в теле промиса, находящийся за пределами resolve или reject, выполняется в любом случае, поэтому 'Resolve Time' и 'Reject Time' выведется в соответствующие промежутки времени.
				Результатом промиса будет то состояния, которое наступило первым. Второе, даже если оно наступает через долю секунды, будет проигнорировано (Promise не может передумать). В нашем случае reject наступает первым, поэтому он и будет обрабатываться. Но поскольку в нашем примере в reject мы выводим не ошибку, как это следует делать, а просто строку, то она будет обрабатываться точно так же, как и resolve.
			</p>
		</li>
		<li>
			<h3>Каким будет ответ функции: <pre>
				function f() {
				  console.log(this.name);
				}

				f = f.bind( {name: "Вася"} ).bind( {name: "Петя" } );

				f();
			</pre></h3>
			<p>Ответ: <pre>'Вася'<pre></p>
			<p>Функция bind привязывает контент к выбранной. Это предотвращает такую ошибку, как потеря контента. Сама функция является оберткой над функцией, поэтому второй вызов bind привязывает контент не к нашей функции, а к ее обертке. А так как обертка никак не использует свой контент, то привязка к ней контента ни на что не повлияет. Здесь важен будет только первый вызов функции bind.</p>
		</li>
		<li>
			<h3>Как сделать так, чтобы в объекте нельзя было изменить какое-нибудь свойство?</h3>
			<p>Ответ: Задать его с помощью метода defineProperty с флагом writable = false</p>
			<p><pre>
				let obj = {public: 'public value'}
				Object.defineProperty(obj, 'protected', {value: "protected value", writable: false})
				obj.protected = 'change';
				выдаст ошибку;
			</pre></p>
		</li>
		<li>
			<h3>В какой последовательности будут выводиться сообщения: 
				<pre>
					console.log('start');
					const intervalId = setInterval(() => {
					  console.log('setInterval');
					}, 0);

					setTimeout(() => {
					  console.log('setTimeout 1'); 

					  const promise = new Promise((resolve, reject) => {
					    resolve('then 4');
					  });

					  promise
					    .then((value) => {
					      console.log(value); 

					      setTimeout(() => {
					        console.log('setTimeout 2');
					        clearInterval(intervalId);
					      }, 0);
					    });
					}, 0);

					const promise = new Promise((resolve, reject) => {
					  resolve('then 1');
					});

					promise
					  .then((value) => {
					    console.log(value);
					    return 'then 2';
					  })
					  .then((value) => {
					    console.log(value); 

					    return new Promise((resolve, reject) => {
					      setTimeout(resolve, 0, 'then 3');
					    });
					  })
					  .then((value) => {
					    console.log(value); 
					  });
					console.log('end');
				</pre>
			</h3>
			<p>Ответ: 
				<pre>
					start
					end
					then 1
					then 2
					setInterval
					setTimeout 1
					then 4
					then 3
					setInterval
					setTimeout 2
				</pre>
			</p>
			<p>
				Это очень сложный вопрос на понимание, в какой последовательности обрабатываются различные процессы в JavaScript. Для того, чтобы правильно ответить на вопрос, необходимо знать, что существуют две очереди выполнения процессов. В первую попадают Microtasks, а во вторую Tasks.
				К разряду Microtasks можно отнести промисы и nextTick. К Tasks - различные таймауты.
				Очередь из микрозадач выполняется с приоритетом. А вторая очередь выполняется только тогда, когда в первой ничего для выполнения не осталось. Поехали:
				Сразу выведятся start, так как это синхронный код. затем во вторую очередь попадает setInterval, следом туда же идет setTimeout. И в первую очередь проходит promise. Дальше следует end, и он сразу же выводится. Получаем:
				<strong>
					start
					end
					В первой очереди: promise(then 1)
					Во второй очереди: setInterval, setTimeout(setTimeout 1)
				</strong>
				Дальше выполняется первая очередь:
				выводится 'then 1', и в первую очередь ставится еще один promise(then 2). И он сразу же выполняется, выводя в консоль 'then 2', и опять же ставит в первую очередь промис(then 3). Результатом выполнения этого промиса является функция setTimeout, которая должна будет вывести then 3, когда придет ее очередь. Она становится в конец первой очереди. В итоге:
				<strong>
					start
					end
					then 1
					then 2
					В первой очереди: 
					Во второй очереди: setInterval, setTimeout(setTimeout 1), setTimeout(then 3)
				</strong>
				Так как в первой очереди задач не осталось, выполняется вторая очередь.
				В результате действия setInterval, в консоль выводится 'setInterval', а интервал уходит в конец второй очереди.
				Дальше, в первой очереди попрежнему ничего нет, продолжается выполнение первой очереди. Срабатывает
				setTimeout(setTimeout 1). В консоль выводится 'setTimeout 1', и в первую очередь залетает promise('then 4').
				В итоге: 
				<strong>
					start
					end
					then 1
					then 2
					setInterval
					setTimeout 1
					then 4
					then 3
					setInterval
					В первой очереди: 
					Во второй очереди: setTimeout(then 3), setInterval
				</strong>
				Так как в первой очереди появилась задача, выполняется она. В консоль выводится 'then 4' и в конец второй очереди ставится setTimeout(setTimeout 2).
				После этого в первой очереди нет ничего, продолжается выполнение второй очереди, то есть отрабатывает setInterval. Он кидает в консоль 'setInterval', и ставит его снова в конец второй очереди. В итоге: 
				<strong>
					start
					end
					then 1
					then 2
					setInterval
					setTimeout 1
					then 4
					then 3
					setInterval
					В первой очереди:
					Во второй очереди: setTimeout(setTimeout 2), setInterval
				</strong> 
					В результате выполнения setTimeout(setTimeout 2) в консоль выводится 'setTimeout 2', а из первой очереди уберается setInterval. И в итоге получается: 
				<strong>
					start
					end
					then 1
					then 2
					setInterval
					setTimeout 1
					then 4
					then 3
					setInterval
					setTimeout 2
					В первой очереди:
					Во второй очереди:
				</strong>
				Ни в первой, ни во второй очередях не осталось задач, процесс завершается.
			</p>
		</li>
	</ol>
</body>
</html>